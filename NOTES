
Packages are unimplemented -- lookups are complicated, but route
No plans to support multiple inheritance
No plans to support metaclasses
Actually, no plans to support inheritance
New-style classes only, (even though it doesn't make a difference)
__slots__ is just more work

I'm not even sure what Elipsis does, or ExtSlice
We're just going to do subscript and slices[start:end]

Yo, deal with builtins

I'm considering using captures for closures at the IR level, and just not handling that for now.

We're almost certainly not going to support cyclicic gc at this point

So apparently globals() and locals() are normal functions, that just so happen to look at their calling frame.  One way or another, I think we'll have to maintain an explicit stack
If we're lucky, we can use C++'s.  Because of this, I'm making the assumption that globals() or locals() can be called anywhere, anytime.
Some analysies will simply not run on any program that uses globals or locals anywhere.  The analysis to determine locals/globals usage is just too complicated to be complete, even if it is extremely conservative, and it's super edgecase-ish.

Ok so one good thing is that globals/locals are in __builtins__, which aren't actually in globals() by default.  Thus, we can *probably* just track if globals/locals are gotten but not immidiately called.  Even doing so, there are some caveats, mostly from doing something to get all of __builtins__, which can lead to globals/locals escaping to the outside world.


yield in a try-finally.  Do you even know what/how that works?

I don't think we're supporting tracebacks.  Sorry.

With statements aren't implemented, but just because they're Try/Catch, and would take uneccessary work.

The orelse clauses of for and while statements are currently unimplemented.  A description of how I would handle them is given in controlFlowTranslator.py

BIG ONE:
a return in a try happens *AFTER* the finally clause.  I don't think C++ does this, and this is actually not that trivial to translate to the target language.  The IR assumes C semantics.  I think I'll rely on an IR transform to make this behave according to Python semantics.

Function's captures aren't identified until after IR generation.  This is done because captures work on >1st degree scopes, and you don't know at the end of the scope all of the locals of the enclosing scopes.  Instead, we're going to identify captures at the end of top-level scopes generation, and we'll do this after IR generation as a correctness pass.

TODO: identify temporaries pass
TODO: handle arguments in namespace considerations 

I removed the isgenerator flag from IRCode -- Generators should probably be distinct from functions some way or another

I removed captures from IRCode -- I think they should be handled at a transform level, so the IR doesn't need to 'know' about them

Because of def `fn(a, (b, c)):` arguments do not always have to be named.  Lambdas also cause this.  Therefore, they should be IRVars, with Assignments first thing.

IRVar unification should actually happen in a pass -- I'm concerned about it, even if it should work

Pass to eliminate unneccesary targets

Move IR emission to AstTranslator -- this will be a PITA in optimization otherwise, not to mention makes cmdline stuff impossible

TODO: Methods are currently undetected.  I believe this should happen in _Call

If there are multiple exception handlers, and one catches, but then raises an exception, are the others considered?

TODO: in function generation, append a return None.  TODO: optimization to remove code in a block after an unconditional return 

Insert an *only once* mechanism into loading modules, and a way to get+clear it for reloads.  Also, add a call to the module's load on imports.

TODO: forward declare functions

TODO: IRAtom -> IRVar 
